import os
import math
import time
import geojson
from geojson import MultiLineString
from shapely import geometry
from shapely.geometry import shape
from shapely.geometry import box
import shapefile
import datetime as dt
import re
import numpy
import geohash
import BoxMapper

class GeohashParser:
    """ Gets smoke metadata with a specific bounding box
    """
    # 57.870760, -133.540154, 46.173395, -129.055971, 1250, 5
    BBOX = [46.173395, -129.055971, 57.870760,-113.540154]
    #BBOX = [47.65661,-139.1346, 60.03192,-110.4208]
    GEOHASH_PRECISION = 5 #5 for 4.9km x 4.9km cells; at around around equator, precision-5: 4.89km x 4.89km, precision-4: 39.1km x 19.5km 
    source_shape_file_path = "C:/temp/"
    source_shape_file = "name_of_file.shp"
    results_geojson_file_path = "c:/temp/geojson/json_" # make sure the folders are created
    results_file_path = "C:/temp/npy/" #npy result files 
    total_geohashes = 0 # counter for logging purpose
    all_geohash_in_bbox = None # static variable generated by get_all_geohash_in_bbox(), do not overwrite
    hours_of_day_to_exclude = {}
    
    def __init__(self, source_shape_file_path, source_shape_file, results_file_path,hours_of_day_to_exclude):
        self.source_shape_file_path = source_shape_file_path
        self.source_shape_file = source_shape_file
        self.results_file_path = results_file_path
        self.hours_of_day_to_exclude = hours_of_day_to_exclude
        
    @staticmethod
    def get_all_geohash_in_bbox():
        if GeohashParser.all_geohash_in_bbox is None:
            print("creating all geohashes in bbox...")
            p = GeohashParser(None,None,None,None)
            #b = box(p.BBOX[0], p.BBOX[1], p.BBOX[2], p.BBOX[3])
            b = box(p.BBOX[1], p.BBOX[0], p.BBOX[3], p.BBOX[2])
            GeohashParser.all_geohash_in_bbox = p.compute_geohash_tiles_from_polygon(b)
        return GeohashParser.all_geohash_in_bbox
        
    def is_geohash_in_bounding_box(self, coordinates, bbox_coordinates):
        """Checks if the box of a geohash is inside the bounding box
    
        :param current_geohash: a geohash
        :param bbox_coordinates: bounding box coordinates
        :return: true if the the center of the geohash is in the bounding box
        """
    
        geohash_in_bounding_box = (bbox_coordinates[0] < coordinates[0] < bbox_coordinates[2]) and (
                bbox_coordinates[1] < coordinates[1] < bbox_coordinates[3])      
        return geohash_in_bounding_box
    
    def build_geohash_box(self, current_geohash):
        """Returns a GeoJSON Polygon for a given geohash
    
        :param current_geohash: a geohash
        :return: a list representation of th polygon
        """
  
        b = geohash.bbox(current_geohash)
        polygon = [(b['w'], b['s']), (b['w'], b['n']), (b['e'], b['n']), (b['e'], b['s'],), (b['w'], b['s'])]
        return polygon
    
    def compute_geohash_tiles_from_polygon(self, polygon):
        """Computes all hex tile in the given polygon
    
        :param polygon: the polygon
        :return: a list of geohashes
        """

        start = time.time()
        geohash_stack = set()
        processed_geohashes = set()
        geohashes = set()
        starting_geohash = geohash.encode(polygon.exterior.coords[0][1], polygon.exterior.coords[0][0], precision=self.GEOHASH_PRECISION)
        coordinates = geohash.decode(starting_geohash)
        point = geometry.Point(coordinates[::-1])
        geohash_stack.add(starting_geohash)
        if self.is_geohash_in_bounding_box(coordinates,self.BBOX):
            geohashes.add(starting_geohash)
        processed_geohashes.add(starting_geohash)     
        while len(geohash_stack) > 0:
            neighbors = geohash.neighbors(geohash_stack.pop())
            for neighbor in neighbors:
                if neighbor not in processed_geohashes:
                    coordinates = geohash.decode(neighbor)
                    point = geometry.Point(coordinates[::-1])
                    if polygon.contains(point):
                        geohash_stack.add(neighbor)
                        if self.is_geohash_in_bounding_box(coordinates,self.BBOX):
                            geohashes.add(neighbor)
                processed_geohashes.add(neighbor)
        end = time.time()
        if len(geohashes)>0:
            print("total geohashes parsed:" + str(len(geohashes)) + ", elapsed time:" + str(round(end-start,1)))
        return geohashes
     
    def write_geohash_layer_to_geojson(self, geohashes, id):
        """Writes a grid layer based on the geohashes. Only used in debug visualization to convert each geohash grid to geojson 
        :param geohashes: a list of geohashes
        """
        if geohashes is None:
            return
        start = time.time()
        file = self.results_geojson_file_path+"_"+str(id)+".json"
        if os.path.exists(file):
            os.remove(file)
        layer = MultiLineString([self.build_geohash_box(gh) for gh in geohashes])
        with open(file, 'wb') as f:
            f.write(geojson.dumps(layer, sort_keys=True).encode('utf-8'))
        end = time.time()
        print("wrote to file:" + file + ", elapsed time:" + str(round(end-start,1)))
   
    # only used in debug visualization to plot each geohash grid mid points of bbox 
    def write_result_array_to_file(self, results, id):
        file = self.results_geojson_file_path+"_"+str(id)+".json"
        if os.path.exists(file):
            os.remove(file)
        with open(file, 'w') as f:
            f.write("{\"coordinates\": [")
            for i in range(len(results)):
                result = results[i]
                end = "," if i<len(results)-1 else "]"
                f.write("["+str(result[3])+","+str(result[2])+"]"+end)
            f.write(",\"type\": \"MultiPoint\"}")
            
    def load_shape_time(self, shape):
        threshold = 60 * 60
        time_results=[]
        for r in shape.iterRecords():
            time_result = []
            epoch_s = (dt.datetime.strptime(r[1], '%Y%j %H%M') - dt.datetime(1970, 1, 1)).total_seconds() 
            epoch_e = (dt.datetime.strptime(r[2], '%Y%j %H%M') - dt.datetime(1970, 1, 1)).total_seconds()
            # sometimes start is later than end time, we'll assume the earlier time is start
            epoch_end = math.floor(max(epoch_s,epoch_e) / threshold) * threshold
            epoch_start = math.floor(min(epoch_s,epoch_e) / threshold) * threshold
            while epoch_end >= epoch_start:
                time_result.append(epoch_start)
                epoch_start += threshold
            time_results.append(time_result)
        return time_results
        
    def load_shape_geos(self, shape):
        features = shape.shapeRecords()
        geos = []
        for feature in features:
            s = feature.shape.__geo_interface__
            geos.append(s)
        return geos
    
    # process and return geohashes with smoke
    def process_shapes(self, geo):
        shp = shape(geo)
        geohashes = self.compute_geohash_tiles_from_polygon(shp)
        self.total_geohashes += len(geohashes)
        return geohashes;
        
    def get_results(self, box_mapper, geohashes, hours_of_day):
        if geohashes is None:
            return
        for g in geohashes:
            b = geohash.bbox(g)
            lat, lon = (b['s']+b['n'])/2 , (b['w']+b['e'])/2
            for hour_of_day in hours_of_day:
                if hour_of_day not in self.hours_of_day_to_exclude:
                    # print(hour_of_day,lat,lon,1)
                    box_mapper.append(hour_of_day,lat,lon,1)
        return box_mapper
    
    def save_results_to_file(self,box_mapper,filename, hour_of_day):
        start = time.time()
        filename = self.results_file_path+filename+"-"+str(hour_of_day)
        numpy.save(filename,box_mapper.to_array(hour_of_day))
        end = time.time()
        print("wrote to numpy file:" + filename + ", time:" + str(round(end-start,1)))
        
    def get_hour_in_epoch(self, filedate, hour):
        """use regex to remove all non numerical characters in filename,
        convert the yyyymmdd string to epoch, then add hour in seconds
    
        :param filedate: string
        :param hour: integers 0-23
        :returns hour in epoch seconds
        """
        date = re.sub("[^0-9]", "", filedate)
        utc_epoch = dt.datetime.timestamp(dt.datetime.strptime(date, "%Y%m%d"))
        hour_in_epoch = utc_epoch + (hour*3600)
        print("getting hour in epoch from:"+date+", hour:"+str(hour)+", result epoch:"+str(hour_in_epoch))
        return hour_in_epoch
    
    def to_hours_of_day(self, times_list):
        """convert time in time_list to hours of day (i.e. 0-23)
    
        :param  
        :returns 
        """
        hours_of_day = []
        prev_hour = -1
        for epoch in times_list:
            hour = dt.datetime.utcfromtimestamp(epoch).hour ##get datetime object, then get hour from it
            if prev_hour > hour:
                break
            hours_of_day.append(hour)
            prev_hour = hour          
        return hours_of_day
        
    def parse(self):
        start = time.time()
        box_mapper = BoxMapper.BoxMapper(self.hours_of_day_to_exclude)
        filedate = self.source_shape_file.replace(".shp","")
        print("geohash parser v2 start parsing " + filedate + "...")
        print("start parsing shapefile...")
        shape = shapefile.Reader(self.source_shape_file_path+self.source_shape_file)
        geos = self.load_shape_geos(shape)
        times_list = self.load_shape_time(shape)
        for i in range(len(geos)):
            print("### processing layer:" + str(i))
            geohashes = self.process_shapes(geos[i]) # result array for this layer
            #write_geohash_layer_to_geojson
            hours_of_day = self.to_hours_of_day(times_list[i])
            self.get_results(box_mapper, geohashes, hours_of_day)
        for hour_of_day in range(24):
            self.save_results_to_file(box_mapper,filedate, hour_of_day)
        end = time.time()
        print("parsing " + filedate+ " completed, total geohashes:" + str(self.total_geohashes) + ", total time:" + str(round(end-start,1)) + " seconds")     